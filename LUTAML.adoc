= LutaML syntax

== `diagram` syntax

`diagram` is a root element for each diagram.

[source,java]
----
diagram MyView {
  import Relationship, Element
  render_option typed_as_associations
  file "my_view.png"
}
----

== Associations

=== Explicit declaration

Syntax:

[source,java]
----
association name {
  owned_type association|composition|aggregation|generalization|uses
  member_type association|composition|aggregation|generalization|uses
  owned association_name[#attribute_name] [{property_string}][cardinality]
  member association_name[#attribute_name] [{property_string}][cardinality]
}
----

where:

* `owned_type` - optional, use to define bidirectional association(association|composition|aggregation|generalization|uses)
* `member_type` - association type(association|composition|aggregation|generalization|uses)
* `owned|member` - end of association, use `\#attribute_name` to set a role name
* `property_string` - property string for attibutes associations
* `cardinality` - examples: '1..*', '*'

Example:

[source,java]
----
class Association {
  +association:
}
class Type {
  +endType:
}

association AssociatingTypeAndAssociation {
  type uses
  from Association#+association {subsets relationship}[*]
  to Type#+/endType {readOnly, subsets relatedElement} [1..*]
}
----

=== Undirected associations

The simplest way to define relationship between two classes is to use `generalize` keyword:

[source,java]
----
class Pet {}
class Cat {
  generalize Pet
}
----

=== Attribute relationship

Derived attribute `relatedElement` can have 1 to many `Element` associated with it through `union`

[source,java]
----
class Relationship {
   +/relatedElement: Element[1..*] {union}
}
class Element {}
----

== Attributes/entries

=== Definition

Full syntax:

[source,java]
----
[visibility][/][attribute] name [:type][multiplicity][=initial value][{property string}]
----

where:

* `visibility` can be equal to `-` - private, `+` - public, `#` - protected, `~` - friendly
* `attribute` - attrbute keyword
* `/` - symbolizes a derived attribute.
* `multiplicity` -  Multiplicity is in square brackets (e.g. [1..*]).
* `initial value` - Default value specifies the initial value of the attribute.
* `property string` - Property string indicates a modifier that applies to the attribute:
  ** {readonly}: the property can be read but not changed.
  ** {union}: the property is a union of subsets.
  ** {subsets <property>}: the property is a subset of <property>.
  ** {redefines <property>}: the property is a new definition of <property> (overwritten by inheritance).


One can use explicit or implicit syntax for attribute definition

explicit syntax:

[source,java]
----
class A {
  attribute my_attribute
}

enum A {
  entry my_val2
}
----

implicit syntax:

[source,java]
----
class A {
  my_attribute
}

enum A {
  my_val2
}
----

=== Attribute visibility

Syntax for defining visibility: [+|-|#|~] [attribute] attribute_name. LutaML uses these modificators to define attribute(entry) visbility:

+ => public
- => private
# => protected
~ => package

example:

[source,java]
----
class Figure {
  // Public attribute `radius`
  + radius
  // private attribute `filled`
  - filled
  // protected attribute `length`
  # length
}
----

== Methods

Syntax for defining methods:

[source,java]
----
[visbility] method-name (parameter-list): return type {property-modifier}
----

where:
- `visibility` can be equal to `-` - private, `+` - public, `#` - protected, `~` - friendly
- `parameter-list` - parameter list
- `property-modifier` - can be equal to `redefines`, `query`, `ordered`(`unordered`), `unique`(`nonunique`)

Syntax for a `parameter-list`:

[source,java]
----
[direction] name:type [multiplicity] [=default] [{property string}]
----

where:
- `direction` - can be equal to `in`, `out`, `inout` or `return`

== import files

Use `include` special word:

[source,java]
----
include path/to/file
----

== Package syntax

Namespaces
Def.-A named element is an element that can have a name and a defined visibility (public, private, protected, package):

[source,java]
----
+ => public
- => private
# => protected
~ => package
----

The name of the element and its visibility are optional.

[source,java]
----
package Customers {
  class Insurance {}
  - class PrivateInsurance {}
  # class ProtectedInsurance {}
}
----

== Code comments

Use `//` notation for LutaML comments skipped by parser, example:

[source,java]
----
// TODO: implement
abstract class Pet {}
----

== Comment objects diagram

Use `%` to create comment object for diagram entry or use `comment` notation to create object explicitly.

[source,java]
----
class A as class_a
enum A as enum_a {
  % attribute foo, represents - attribute comment
  foo
  bar
}
comment MyComment {
  My comment
}

class_a -> MyComment
enum_a -> MyComment
----

== Value specification

A value specification indicates one or several values in a model. Examples for value specifications include simple, mathematical expressions, such as 4+2, and expressions with values from the object model, Integer::MAX_INT-1

[source,java]
----
class {Class name, if any} {as ref name, optional} {
  {attribute name} = {attribute value}
  {attribute name}:{attribute class} = {attribute value}
}

instance :{Class name, if any} {as ref name, optional} {
  {attribute name} = {attribute value}
  {attribute name}:{attribute class} = {attribute value}
}
----